## 2020-05-29：每日两题

###209. 长度最小的子数组:给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中
满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，
返回 0。
#### 思路
如果直接使用暴力法，需要双重循环依次以数组中的数字为开头，时间复杂度会达到n的平方，
所以要降低时间复杂度可以用双指针法，即每次当总数大于S时，进行数组长度大小的最小值
判断，并且移动左边的指针，使其长度缩小，如果小于了s，则继续移动右指针。
#### 代码
```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
       int min = Integer.MAX_VALUE;
       int sum=0;
       int left=0;
       for(int i=0;i<nums.length;i++){
           sum+=nums[i];
           while(sum>=s){
               min=Math.min(min,i-left+1);
               sum-=nums[left++];
           }
       }
       return min==Integer.MAX_VALUE?0:min;
    }
}
```

###222. 完全二叉树的节点个数：给出一个完全二叉树，求出该树的节点个数。
#### 思路
使用递归前序遍历将所有遍历到的结点放入一个容器中，返回容器的容量即可
#### 代码
```java
class Solution {
    List<Integer> al=new ArrayList();
    public int countNodes(TreeNode root) {
        if(root==null)return 0;
        countNodes(root.left);
        al.add(root.val);
        countNodes(root.right);
        return al.size();
        //简易法
        //return root != null ? 1 + countNodes(root.right) + countNodes(root.left) : 0;
    }
}
```



<details class="details-reset details-overlay details-overlay-dark" style="box-sizing: border-box; display: block;"><summary data-hotkey="l" aria-label="Jump to line" role="button" style="box-sizing: border-box; display: list-item; cursor: pointer; list-style: none;"></summary></details>

 