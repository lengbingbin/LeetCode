## 2020-05-30：每日两题

###945. 使数组唯一的最小增量:给定整数数组 A，每次 move 操作将会选择任意 A[i]，并
将其递增 1。返回使 A 中的每个值都是唯一的最少操作次数。
#### 思路
先排序，当发现数组中的数字小于等于前一个数（等于的话不用说，重复了，小于的话是因为
你改变了某个数（+1）导致后面的数可能小于，比如1 1 1->1 2 1;那么就需要增加，增加的
话需要比前一个和他相等或者大于的数+1，即可）该题暴力法超时！！！
#### 代码
```java
class Solution {
    public int minIncrementForUnique(int[] A) {
        int count=0;
        Arrays.sort(A);
        for(int i=1;i<A.length;i++){
            if(A[i]<=A[i-1]){
                count+=A[i-1]-A[i]+1;
                A[i]=A[i-1]+1;   
            }
        }
        return count;
    }
}
```

###222. 完全二叉树的节点个数还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多
少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连
接起来，并且每根火柴都要用到。输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出
即为是否能用所有的火柴拼成正方形。
#### 思路
使用回溯法，用count记录边数，当边的长度都达到总数除以4，count++，当count等于4，
返回true,否则为false
#### 代码
```java
class Solution {
    //int count=0;
    public boolean makesquare(int[] nums) {
        //正方形每条边的长度
        int sum=0;
        int count=0;
        if(nums.length<4)return false;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
        }
        Arrays.sort(nums);
        if(sum%4!=0)return false;
        int len=sum/4;
        int[] used=new int[nums.length];
        return trackback(nums,0,0,len,count,used);

    }

    public boolean trackback(int[] nums,int begin,int cur,int target,int count,int[] used){
        //如果有了4组和相同的值，返回true
        if(count==4)return true;
        //如果此时有了一个等于目标值的和，去继续遍历下一个
        if(cur==target){
            return trackback(nums,0,0,target,count+1,used);
        }
        //如果当前的这一轮中有一个和大于target，那么这一轮就不能构成目标数
        if(cur>target)return false;
        for(int i=begin;i<nums.length;i++){
            //相同相邻的数且未被访问过不能加！！！！提高效率
            //if(i>1&&nums[i]==nums[i-1]&&used[i-1]==0)continue;
            if(used[i]==0){
                cur+=nums[i];
                used[i]=1;
                //产生层级由下到上依次返回true
                if(trackback(nums,i+1,cur,target,count,used)){
                    return true;
                }
                used[i]=0;
                cur-=nums[i];
            }
        } 
        return false;    
    }
}
```



<details class="details-reset details-overlay details-overlay-dark" style="box-sizing: border-box; display: block;"><summary data-hotkey="l" aria-label="Jump to line" role="button" style="box-sizing: border-box; display: list-item; cursor: pointer; list-style: none;"></summary></details>

 