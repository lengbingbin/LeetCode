## 2020-06-01：每日两题

###343. 整数拆分：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些
整数的乘积最大化。 返回你可以获得的最大乘积。
#### 思路
使用动态规划的思想从底向上，依次求出其所有可能包含的两个相加等于他的数的乘积的值
然后求最大，放入dp中
#### 代码
```java
class Solution {
    public int integerBreak(int n) {
        if(n==1||n==0)return 0;
        if(n==2)return 1;
        if(n==3)return 2;
        int[] dp=new int[n+1];
        for(int i=0;i<=4;i++){
            dp[i]=i;
        }
        for(int i=5;i<=n;i++){
            for(int j=i/2;j<=i-1;j++){
                int num1=j;
                int num2=i-j;
                int res=dp[num1]*dp[num2];
                dp[i]=Math.max(dp[i],res);
            }
        }
        return dp[n];
    }
}
```

###357. 计算各个位数不同的数字个数：给定一个非负整数 n，计算各位数字
都不同的数字 x 的个数，其中 0 ≤ x < 10n 。
#### 思路
使用dp，dp[i]用来存储在i位，有多少个各位不同的数，根据数学分析可得出每一个位为
dp[i-1]*count--;count从9开始，对应9个数字（第一位不能为0，第二位不能选第一位选了
的），所以最终答案就是dp[1]到dp[i]的和
#### 代码
```java
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if(n==0)return 1;
        if(n==1)return 10;
        int[] dp=new int[n+1];
        int sum=0;
        dp[1]=10;
        dp[2]=81;
        int count=8;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]*count;
            count--;
        }
        for(int i=1;i<=n;i++){
            sum+=dp[i];
        }
        return sum;
    }
}
```



<details class="details-reset details-overlay details-overlay-dark" style="box-sizing: border-box; display: block;"><summary data-hotkey="l" aria-label="Jump to line" role="button" style="box-sizing: border-box; display: list-item; cursor: pointer; list-style: none;"></summary></details>

 